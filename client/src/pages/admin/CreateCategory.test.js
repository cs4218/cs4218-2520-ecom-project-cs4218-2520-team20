// Seah Minlong, A0271643E
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import axios from "axios";
import toast from "react-hot-toast";
import { MemoryRouter } from "react-router-dom";
import CreateCategory from "./CreateCategory";

jest.mock("axios");
jest.mock("react-hot-toast");

jest.mock("../../components/Layout", () => ({ children }) => (
	<div data-testid="LayoutMock">{children}</div>
));

jest.mock("../../components/AdminMenu", () => () => (
	<div data-testid="AdminMenuMock">AdminMenuMock</div>
));

jest.mock(
	"../../components/Form/CategoryForm",
	() =>
		({ handleSubmit, value, setValue }) => (
			<form onSubmit={handleSubmit} data-testid="CategoryFormMock">
				<input
					aria-label="Category Name"
					value={value}
					onChange={(e) => setValue(e.target.value)}
				/>
				<button type="submit">Submit</button>
			</form>
		),
);

jest.mock("antd", () => {
	return {
		Modal: ({ onCancel, visible, open, children }) => {
			if (!visible && !open) return null;
			return (
				<div data-testid="ModalMock">
					<button onClick={onCancel} aria-label="Close Modal">
						X
					</button>
					{children}
				</div>
			);
		},
	};
});

const renderCreateCategory = () => {
	render(
		<MemoryRouter>
			<CreateCategory />
		</MemoryRouter>,
	);
};

describe("CreateCategory", () => {
	beforeEach(() => {
		jest.clearAllMocks();
		jest.spyOn(console, "log").mockImplementation(() => {});
		jest.spyOn(console, "error").mockImplementation(() => {});

		// Default happy path for get-category
		axios.get.mockResolvedValue({
			data: {
				success: true,
				category: [
					{ _id: "1", name: "Electronics" },
					{ _id: "2", name: "Books" },
				],
			},
		});
	});

	afterEach(() => {
		console.log.mockRestore();
		console.error.mockRestore();
	});

	it("renders the component and fetches categories correctly", async () => {
		renderCreateCategory();

		expect(screen.getByTestId("LayoutMock")).toBeInTheDocument();
		expect(screen.getByTestId("AdminMenuMock")).toBeInTheDocument();

		await screen.findByText("Electronics");
		expect(screen.getByText("Books")).toBeInTheDocument();
		expect(axios.get).toHaveBeenCalledWith("/api/v1/category/get-category");
	});

	it("creates a new category successfully", async () => {
		// Arrange
		axios.get
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [{ _id: "1", name: "Electronics" }],
				},
			})
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [
						{ _id: "1", name: "Electronics" },
						{ _id: "3", name: "New Category" },
					],
				},
			});

		axios.post.mockResolvedValueOnce({
			data: { success: true },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const inputs = screen.getAllByLabelText("Category Name");
		const mainInput = inputs[0];

		fireEvent.change(mainInput, { target: { value: "New Category" } });

		const submitBtns = screen.getAllByText("Submit");
		fireEvent.click(submitBtns[0]);

		// Assert
		await waitFor(() =>
			expect(axios.post).toHaveBeenCalledWith(
				"/api/v1/category/create-category",
				{
					name: "New Category",
				},
			),
		);
		expect(toast.success).toHaveBeenCalledWith("New Category is created");

		// Wait for the re-fetch to update the UI
		await screen.findByText("New Category");
		expect(axios.get).toHaveBeenCalledTimes(2);
	});

	it("shows error toast when category creation fails", async () => {
		// Arrange
		axios.post.mockResolvedValueOnce({
			data: { success: false, message: "Error creating category" },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const inputs = screen.getAllByLabelText("Category Name");
		fireEvent.change(inputs[0], { target: { value: "Fail Category" } });

		const submitBtns = screen.getAllByText("Submit");
		fireEvent.click(submitBtns[0]);

		// Assert
		await waitFor(() =>
			expect(toast.error).toHaveBeenCalledWith("Error creating category"),
		);
	});

	it("shows generic error when category creation has no response", async () => {
		// Arrange
		axios.post.mockRejectedValueOnce(new Error("Network Error"));

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const inputs = screen.getAllByLabelText("Category Name");
		fireEvent.change(inputs[0], { target: { value: "Offline Category" } });

		const submitBtns = screen.getAllByText("Submit");
		fireEvent.click(submitBtns[0]);

		// Assert
		await waitFor(() => expect(axios.post).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Something went wrong");
	});

	// The following test was generated by GitHub Copilot using the model Gemini 3 Pro.
	// Prompt: "Write a unit test that verifies updating a category via the modal. Ensure it mocks the API call, interacts with the modal input, submits the form, and asserts the correct success toast message."
	it("updates a category successfully via modal", async () => {
		// Arrange
		axios.get
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [{ _id: "1", name: "Electronics" }],
				},
			})
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [{ _id: "1", name: "Electronics Updated" }],
				},
			});

		axios.put.mockResolvedValueOnce({
			data: { success: true },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		// Find edit button for Electronics
		const editBtn = screen.getAllByText("Edit")[0];
		fireEvent.click(editBtn);

		// Modal should appear
		expect(await screen.findByTestId("ModalMock")).toBeInTheDocument();

		// Find input inside modal.
		// Since Modal is now rendered, there are two CategoryForms.
		// 1st is main form, 2nd is inside modal.
		const inputs = screen.getAllByLabelText("Category Name");
		const modalInput = inputs[1];

		// Should be pre-filled with "Electronics"
		expect(modalInput.value).toBe("Electronics");

		fireEvent.change(modalInput, {
			target: { value: "Electronics Updated" },
		});

		const submitBtns = screen.getAllByText("Submit");
		const modalSubmitBtn = submitBtns[1]; // 2nd submit button
		fireEvent.click(modalSubmitBtn);

		// Assert
		await waitFor(() =>
			expect(axios.put).toHaveBeenCalledWith(
				"/api/v1/category/update-category/1",
				{
					name: "Electronics Updated",
				},
			),
		);
		expect(toast.success).toHaveBeenCalledWith(
			"Electronics Updated is updated",
		);

		// Wait for UI to update with new name
		await screen.findByText("Electronics Updated");
	});

	it("deletes a category successfully", async () => {
		// Arrange
		axios.get
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [{ _id: "1", name: "Electronics" }],
				},
			})
			.mockResolvedValueOnce({
				data: {
					success: true,
					category: [],
				},
			});

		axios.delete.mockResolvedValueOnce({
			data: { success: true },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		// Find delete button
		const deleteBtn = screen.getAllByText("Delete")[0];
		fireEvent.click(deleteBtn);

		// Assert
		await waitFor(() =>
			expect(axios.delete).toHaveBeenCalledWith(
				"/api/v1/category/delete-category/1",
			),
		);
		expect(toast.success).toHaveBeenCalledWith("category is deleted");

		// Ensure Electronics is removed
		await waitFor(() =>
			expect(screen.queryByText("Electronics")).not.toBeInTheDocument(),
		);
	});

	it("shows error toast if get categories fails", async () => {
		// Arrange
		axios.get.mockRejectedValueOnce(new Error("Network Error"));

		// Act
		renderCreateCategory();

		// Assert
		await waitFor(() =>
			expect(toast.error).toHaveBeenCalledWith(
				"Something went wrong in getting category",
			),
		);
	});

	it("prevents creating a category that already exists", async () => {
		// Arrange
		axios.post.mockRejectedValueOnce({
			response: {
				data: { message: "Category Already Exists" },
			},
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const inputs = screen.getAllByLabelText("Category Name");
		const mainInput = inputs[0];
		fireEvent.change(mainInput, { target: { value: "Electronics" } });

		const submitBtns = screen.getAllByText("Submit");
		fireEvent.click(submitBtns[0]);

		// Assert
		await waitFor(() => expect(axios.post).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Category Already Exists");
	});

	it("prevents updating a category to a name that already exists", async () => {
		// Arrange
		axios.put.mockRejectedValueOnce({
			response: {
				data: { message: "Category Already Exists" },
			},
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const editBtn = screen.getAllByText("Edit")[0];
		fireEvent.click(editBtn);

		expect(await screen.findByTestId("ModalMock")).toBeInTheDocument();

		const inputs = screen.getAllByLabelText("Category Name");
		const modalInput = inputs[1];
		fireEvent.change(modalInput, { target: { value: "Books" } });

		const submitBtns = screen.getAllByText("Submit");
		const modalSubmitBtn = submitBtns[1];
		fireEvent.click(modalSubmitBtn);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(axios.put).toHaveBeenCalledWith(
			"/api/v1/category/update-category/1",
			{ name: "Books" },
		);
		expect(toast.error).toHaveBeenCalledWith("Category Already Exists");
	});

	it("handles server error when deleting a category", async () => {
		// Arrange
		axios.delete.mockRejectedValueOnce(new Error("Delete Failed"));

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const deleteBtn = screen.getAllByText("Delete")[0];
		fireEvent.click(deleteBtn);

		// Assert
		await waitFor(() => expect(axios.delete).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Something went wrong");
	});

	it("handles failure response from server when updating a category", async () => {
		// Arrange
		axios.put.mockResolvedValueOnce({
			data: { success: false, message: "Update Failed" },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const editBtn = screen.getAllByText("Edit")[0];
		fireEvent.click(editBtn);

		expect(await screen.findByTestId("ModalMock")).toBeInTheDocument();

		const inputs = screen.getAllByLabelText("Category Name");
		const modalInput = inputs[1];

		fireEvent.change(modalInput, { target: { value: "Updated Name" } });

		const submitBtns = screen.getAllByText("Submit");
		const modalSubmitBtn = submitBtns[1];
		fireEvent.click(modalSubmitBtn);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(axios.put).toHaveBeenCalledWith(
			"/api/v1/category/update-category/1",
			{ name: "Updated Name" },
		);
		expect(toast.error).toHaveBeenCalledWith("Update Failed");
	});

	it("shows generic error when update fails without response", async () => {
		// Arrange
		axios.put.mockRejectedValueOnce(new Error("Network Error"));

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const editBtn = screen.getAllByText("Edit")[0];
		fireEvent.click(editBtn);

		expect(await screen.findByTestId("ModalMock")).toBeInTheDocument();

		const inputs = screen.getAllByLabelText("Category Name");
		const modalInput = inputs[1];
		fireEvent.change(modalInput, { target: { value: "Any Name" } });

		const submitBtns = screen.getAllByText("Submit");
		const modalSubmitBtn = submitBtns[1];
		fireEvent.click(modalSubmitBtn);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Something went wrong");
	});

	it("shows error toast when delete returns failure response", async () => {
		// Arrange
		axios.delete.mockResolvedValueOnce({
			data: { success: false, message: "Cannot delete category" },
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const deleteBtn = screen.getAllByText("Delete")[0];
		fireEvent.click(deleteBtn);

		// Assert
		await waitFor(() => expect(axios.delete).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Cannot delete category");
	});

	it("shows server error message when delete fails with response data", async () => {
		// Arrange
		axios.delete.mockRejectedValueOnce({
			response: {
				data: { message: "Delete failed" },
			},
		});

		renderCreateCategory();
		await screen.findByText("Electronics");

		// Act
		const deleteBtn = screen.getAllByText("Delete")[0];
		fireEvent.click(deleteBtn);

		// Assert
		await waitFor(() => expect(axios.delete).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Delete failed");
	});

	it("closes the modal when cancel is clicked", async () => {
		renderCreateCategory();
		await screen.findByText("Electronics");

		// Open modal
		const editBtn = screen.getAllByText("Edit")[0];
		fireEvent.click(editBtn);
		expect(await screen.findByTestId("ModalMock")).toBeInTheDocument();

		// Close modal
		const closeBtn = screen.getByLabelText("Close Modal");
		fireEvent.click(closeBtn);

		// Assert modal is gone
		await waitFor(() =>
			expect(screen.queryByTestId("ModalMock")).not.toBeInTheDocument(),
		);
	});
});
