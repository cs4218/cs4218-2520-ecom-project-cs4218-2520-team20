// Seah Minlong, A0271643E
import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import axios from "axios";
import toast from "react-hot-toast";
import { MemoryRouter, Routes, Route } from "react-router-dom";
import UpdateProduct from "./UpdateProduct";

jest.mock("axios");
jest.mock("react-hot-toast");

const mockNavigate = jest.fn();

jest.mock("react-router-dom", () => {
	const actual = jest.requireActual("react-router-dom");
	return {
		...actual,
		useNavigate: () => mockNavigate,
	};
});

jest.mock("../../components/Layout", () => ({ children }) => (
	<div data-testid="LayoutMock">{children}</div>
));

jest.mock("../../components/AdminMenu", () => () => (
	<div data-testid="AdminMenuMock">AdminMenuMock</div>
));

jest.mock("antd", () => {
	const Select = ({ children, onChange, value }) => (
		<select
			data-testid="antd-select"
			onChange={(e) => onChange?.(e.target.value)}
			value={value}
		>
			{children}
		</select>
	);

	Select.Option = ({ value, children }) => (
		<option value={value}>{children}</option>
	);

	return { Select };
});

const mockProduct = {
	_id: "123",
	name: "Existing Product",
	description: "Existing Description",
	price: 100,
	quantity: 10,
	shipping: false,
	category: { _id: "cat1", name: "Category 1" },
};

const renderUpdateProduct = () =>
	render(
		<MemoryRouter
			initialEntries={["/dashboard/admin/product/test-product"]}
		>
			<Routes>
				<Route
					path="/dashboard/admin/product/:slug"
					element={<UpdateProduct />}
				/>
			</Routes>
		</MemoryRouter>,
	);

describe("UpdateProduct", () => {
	beforeEach(() => {
		jest.clearAllMocks();
		jest.spyOn(console, "log").mockImplementation(() => {});

		// Default mocks
		axios.get.mockImplementation((url) => {
			if (url.includes("/get-product/")) {
				return Promise.resolve({
					data: {
						product: mockProduct,
					},
				});
			}
			if (url.includes("/get-category")) {
				return Promise.resolve({
					data: {
						success: true,
						category: [
							{ _id: "cat1", name: "Category 1" },
							{ _id: "cat2", name: "Category 2" },
						],
					},
				});
			}
			return Promise.reject(new Error("not found"));
		});

		global.URL.createObjectURL = jest.fn(() => "blob:preview-url");
		global.URL.revokeObjectURL = jest.fn();
	});

	afterEach(() => {
		console.log.mockRestore();
	});

	// The following test was generated by GitHub Copilot using the model Gemini 3 Pro.
	// Prompt: "Write tests for UpdateProduct in the same style as CreateProduct. For a start, write tests that are checking for the same thing as what CreateProduct is doing, that 1. A product is created succesfully when all required fills are filled"
	it("updates the product successfully when fields are updated", async () => {
		// Arrange
		axios.put.mockResolvedValueOnce({
			data: { success: true, message: "Product Updated Successfully" },
		});

		renderUpdateProduct();

		// Wait for form to load data
		await screen.findByDisplayValue("Existing Product");

		const fileInput = screen.getByLabelText(/upload photo/i, {
			selector: "input",
		});
		const file = new File(["fake"], "new.png", { type: "image/png" });

		// Act - Update some fields
		fireEvent.change(fileInput, { target: { files: [file] } });
		fireEvent.change(screen.getByPlaceholderText(/write a name/i), {
			target: { value: "Updated Product" },
		});
		fireEvent.change(screen.getByPlaceholderText(/write a description/i), {
			target: { value: "Updated Desc" },
		});

		fireEvent.click(
			screen.getByRole("button", { name: /update product/i }),
		);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(axios.put).toHaveBeenCalledWith(
			`/api/v1/product/update-product/${mockProduct._id}`,
			expect.any(FormData),
		);
		expect(toast.success).toHaveBeenCalledWith(
			"Product Updated Successfully",
		);
		expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
	});

	// The following test was generated by GitHub Copilot using the model Gemini 3 Pro.
	// Prompt: "Write tests for UpdateProduct in the same style as CreateProduct... 2. An error message is shown from the backend correctly when there are issues with the fields"
	it.each([
		["name", "Name is Required"],
		["description", "Description is Required"],
		["price", "Price is Required"],
		["category", "Category is Required"],
		["quantity", "Quantity is Required"],
		["shipping", "Shipping is Required"],
		["photo", "Photo is required and should be less then 1mb"],
	])(
		"shows an error toast from backend when %s is missing or invalid",
		async (missingField, backendMessage) => {
			// Arrange
			axios.put.mockRejectedValueOnce({
				response: { status: 400, data: { error: backendMessage } },
			});

			renderUpdateProduct();

			// Wait for load
			await screen.findByDisplayValue("Existing Product");

			// Act
			fireEvent.click(
				screen.getByRole("button", { name: /update product/i }),
			);

			// Assert
			await waitFor(() => expect(axios.put).toHaveBeenCalled());
			expect(toast.error).toHaveBeenCalledWith(backendMessage);
			expect(mockNavigate).not.toHaveBeenCalled();
		},
	);

	it("populates fields with initial data correctly", async () => {
		renderUpdateProduct();

		// Wait for data to load
		await screen.findByDisplayValue("Existing Product");

		expect(
			screen.getByDisplayValue("Existing Product"),
		).toBeInTheDocument();
		expect(
			screen.getByDisplayValue("Existing Description"),
		).toBeInTheDocument();
		expect(screen.getByDisplayValue("100")).toBeInTheDocument(); // Price
		expect(screen.getByDisplayValue("10")).toBeInTheDocument(); // Quantity

		const selects = screen.getAllByTestId("antd-select");
		expect(selects[0]).toHaveValue("cat1");
		expect(selects[1]).toHaveValue("0"); // Shipping
	});

	it("deletes the product successfully", async () => {
		// Arrange
		axios.delete.mockResolvedValueOnce({
			data: { success: true },
		});
		window.confirm = jest.fn(() => true); // User clicks OK

		renderUpdateProduct();
		await screen.findByDisplayValue("Existing Product");

		// Act
		const deleteBtn = screen.getByText("DELETE PRODUCT");
		fireEvent.click(deleteBtn);

		// Assert
		expect(window.confirm).toHaveBeenCalled();
		expect(axios.delete).toHaveBeenCalledWith(
			`/api/v1/product/delete-product/${mockProduct._id}`,
		);
		await waitFor(() => {
			expect(toast.success).toHaveBeenCalledWith(
				"Product Deleted Successfully",
			);
		});
		expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
	});

	it("does not delete product if confirmation is cancelled", async () => {
		// Arrange
		window.confirm = jest.fn(() => false); // User clicks Cancel

		renderUpdateProduct();
		await screen.findByDisplayValue("Existing Product");

		// Act
		const deleteBtn = screen.getByText("DELETE PRODUCT");
		fireEvent.click(deleteBtn);

		// Assert
		expect(window.confirm).toHaveBeenCalled();
		expect(axios.delete).not.toHaveBeenCalled();
	});

	it("shows error toast if delete fails", async () => {
		// Arrange
		axios.delete.mockRejectedValueOnce(new Error("Delete failed"));
		window.confirm = jest.fn(() => true);

		renderUpdateProduct();
		await screen.findByDisplayValue("Existing Product");

		// Act
		const deleteBtn = screen.getByText("DELETE PRODUCT");
		fireEvent.click(deleteBtn);

		// Assert
		await waitFor(() => {
			expect(toast.error).toHaveBeenCalledWith("Something went wrong");
		});
	});

	it("shows error toast when getting single product fails", async () => {
		// Arrange
		axios.get.mockImplementation((url) => {
			if (url.includes("/get-product/")) {
				return Promise.reject(new Error("Product not found"));
			}
			if (url.includes("/get-category")) {
				return Promise.resolve({
					data: {
						success: true,
						category: [{ _id: "cat1", name: "Category 1" }],
					},
				});
			}
			return Promise.reject(new Error("not found"));
		});

		renderUpdateProduct();

		// Assert - console.log should be called with the error
		await waitFor(() => expect(console.log).toHaveBeenCalled());
	});

	it("shows error toast when getting categories fails", async () => {
		// Arrange
		axios.get.mockImplementation((url) => {
			if (url.includes("/get-product/")) {
				return Promise.resolve({
					data: { product: mockProduct },
				});
			}
			if (url.includes("/get-category")) {
				return Promise.reject(new Error("Category fetch failed"));
			}
			return Promise.reject(new Error("not found"));
		});

		renderUpdateProduct();

		// Assert
		await waitFor(() =>
			expect(toast.error).toHaveBeenCalledWith(
				"Something went wrong in getting category",
			),
		);
	});

	it("shows error toast when update returns failure response", async () => {
		// Arrange
		axios.put.mockResolvedValueOnce({
			data: { success: false, message: "Update validation failed" },
		});

		renderUpdateProduct();
		await screen.findByDisplayValue("Existing Product");

		// Act
		fireEvent.click(
			screen.getByRole("button", { name: /update product/i }),
		);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(toast.error).toHaveBeenCalledWith("Update validation failed");
		expect(mockNavigate).not.toHaveBeenCalled();
	});

	it("allows changing category, price, quantity, and shipping fields", async () => {
		// Arrange
		axios.put.mockResolvedValueOnce({
			data: { success: true, message: "Product Updated Successfully" },
		});

		renderUpdateProduct();
		await screen.findByDisplayValue("Existing Product");

		// Act - change category select
		const selects = screen.getAllByTestId("antd-select");
		fireEvent.change(selects[0], { target: { value: "cat2" } });

		// Change price
		fireEvent.change(screen.getByPlaceholderText(/write a price/i), {
			target: { value: "200" },
		});

		// Change quantity
		fireEvent.change(screen.getByPlaceholderText(/write a quantity/i), {
			target: { value: "50" },
		});

		// Change shipping
		fireEvent.change(selects[1], { target: { value: "1" } });

		fireEvent.click(
			screen.getByRole("button", { name: /update product/i }),
		);

		// Assert
		await waitFor(() => expect(axios.put).toHaveBeenCalled());
		expect(toast.success).toHaveBeenCalledWith(
			"Product Updated Successfully",
		);
		expect(mockNavigate).toHaveBeenCalledWith("/dashboard/admin/products");
	});
});
